// app/api/analyze-conversation/route.ts - Robust Version with Fallback
export async function POST(request: Request) {
  try {
    const { conversation, scenario, session_id } = await request.json();
    
    if (!conversation || !scenario) {
      return Response.json(
        { success: false, error: 'Conversation and scenario are required' },
        { status: 400 }
      );
    }

    if (conversation.length < 2) {
      return Response.json(
        { success: false, error: 'Not enough conversation data to analyze' },
        { status: 400 }
      );
    }

    console.log('🧠 Starting conversation analysis for session:', session_id);
    console.log('📊 Analyzing', conversation.length, 'messages in', scenario.role);

    // Try AI analysis first, fall back to rule-based analysis if it fails
    let analysisResult;
    
    try {
      analysisResult = await performAIAnalysis(conversation, scenario, session_id);
      console.log('✅ AI analysis completed successfully');
    } catch (aiError) {
      console.warn('⚠️ AI analysis failed, using rule-based fallback:', aiError);
      analysisResult = performRuleBasedAnalysis(conversation, scenario, session_id);
    }

    return Response.json({
      success: true,
      data: analysisResult
    });

  } catch (error) {
    console.error('💥 Analysis API error:', error);
    
    // Even if everything fails, provide basic feedback
    const fallbackResult = createFallbackAnalysis(request);
    
    return Response.json({
      success: true,
      data: fallbackResult
    });
  }
}

// Try AI analysis with Gemini
async function performAIAnalysis(conversation: any[], scenario: any, session_id: string) {
  const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
  
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY not configured');
  }

  // Build analysis prompt
  const analysisPrompt = buildAnalysisPrompt(conversation, scenario);
  
  console.log('🤖 Calling Gemini for conversation analysis...');
  
  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${GEMINI_API_KEY}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: analysisPrompt }] }],
        generationConfig: {
          temperature: 0.3,
          topK: 20,
          topP: 0.8,
          maxOutputTokens: 1000,
          candidateCount: 1,
        }
      }),
      // Add timeout to prevent hanging
      signal: AbortSignal.timeout(30000) // 30 second timeout
    }
  );

  if (!response.ok) {
    const errorText = await response.text();
    console.error('❌ Gemini API error:', response.status, errorText);
    throw new Error(`Gemini API failed: ${response.status}`);
  }

  const data = await response.json();
  const aiAnalysis = data.candidates?.[0]?.content?.parts?.[0]?.text;

  if (!aiAnalysis) {
    throw new Error('No analysis content from Gemini');
  }

  // Parse AI response into structured feedback
  const parsedAnalysis = parseAIAnalysis(aiAnalysis, conversation, scenario);
  
  return {
    ...parsedAnalysis,
    session_id,
    timestamp: new Date().toISOString(),
    analysis_type: 'ai-powered-real'
  };
}

// Rule-based analysis as fallback
function performRuleBasedAnalysis(conversation: any[], scenario: any, session_id: string) {
  console.log('📊 Performing rule-based analysis...');
  
  const userMessages = conversation.filter(msg => msg.speaker === 'user');
  const exchanges = Math.floor(conversation.length / 2);
  
  // Calculate scores based on conversation patterns
  const scores = calculateRuleBasedScores(userMessages, exchanges, scenario);
  
  return {
    session_id,
    overall_score: scores.overall,
    role_scores: scores.categories, // Changed from category_scores to role_scores for frontend compatibility
    conversation_analysis: {
      specific_strengths: generateStrengthsFromRules(userMessages, exchanges),
      specific_improvements: generateImprovementsFromRules(userMessages, exchanges),
      conversation_flow_analysis: `Completed ${exchanges} exchanges with good conversation flow`,
      character_interaction_quality: `Professional interaction with ${scenario.character_name}`,
      ai_assessment: 'Generated by rule-based analysis system'
    },
    coaching_insights: generateCoachingInsights(scores, scenario),
    improvement_areas: generateImprovementAreas(scores),
    strengths: generateStrengths(scores),
    next_session_focus: generateNextFocus(scores, scenario),
    skill_progression: calculateProgression(scores.overall),
    personalized_feedback: `Good practice session! You completed ${exchanges} conversation exchanges. Focus on building confidence and expanding your responses.`,
    timestamp: new Date().toISOString(),
    analysis_type: 'rule-based-fallback'
  };
}

// Calculate scores based on conversation metrics
function calculateRuleBasedScores(userMessages: any[], exchanges: number, scenario: any) {
  let overallScore = 2.0; // Base score
  
  // Bonus for engagement
  if (exchanges >= 3) overallScore += 0.5;
  if (exchanges >= 5) overallScore += 0.5;
  if (exchanges >= 7) overallScore += 0.3;
  
  // Bonus for message quality
  const avgMessageLength = userMessages.reduce((sum, msg) => sum + msg.message.length, 0) / userMessages.length;
  if (avgMessageLength > 20) overallScore += 0.3;
  if (avgMessageLength > 50) overallScore += 0.2;
  
  // Bonus for varied responses
  const uniqueWords = new Set(
    userMessages.flatMap(msg => 
      msg.message.toLowerCase().split(/\s+/).filter((word: string) => word.length > 3)
    )
  ).size;
  if (uniqueWords > 15) overallScore += 0.3;
  
  // Cap at 5.0
  overallScore = Math.min(5.0, overallScore);
  
  // Generate category scores based on overall
  const variance = 0.3;
  const categories = {
    opening_rapport: {
      score: Math.min(5.0, Math.max(1.0, overallScore + (Math.random() - 0.5) * variance)),
      feedback: 'Good opening approach and rapport building'
    },
    discovery_needs: {
      score: Math.min(5.0, Math.max(1.0, overallScore + (Math.random() - 0.5) * variance)),
      feedback: 'Effective questioning and information gathering'
    },
    communication_clarity: {
      score: Math.min(5.0, Math.max(1.0, overallScore + (Math.random() - 0.5) * variance)),
      feedback: 'Clear and professional communication style'
    },
    problem_solving: {
      score: Math.min(5.0, Math.max(1.0, overallScore + (Math.random() - 0.5) * variance)),
      feedback: 'Good problem-solving approach'
    },
    professionalism: {
      score: Math.min(5.0, Math.max(1.0, overallScore + (Math.random() - 0.5) * variance)),
      feedback: 'Maintained professional demeanor throughout'
    }
  };
  
  return {
    overall: overallScore,
    categories
  };
}

function generateStrengthsFromRules(userMessages: any[], exchanges: number): string[] {
  const strengths = [];
  
  if (exchanges >= 5) {
    strengths.push('Maintained sustained engagement throughout the conversation');
  }
  
  if (userMessages.some(msg => msg.message.includes('?'))) {
    strengths.push('Asked relevant questions to gather information');
  }
  
  const avgLength = userMessages.reduce((sum, msg) => sum + msg.message.length, 0) / userMessages.length;
  if (avgLength > 30) {
    strengths.push('Provided detailed and thoughtful responses');
  }
  
  if (strengths.length === 0) {
    strengths.push('Actively participated in the conversation');
  }
  
  return strengths;
}

function generateImprovementsFromRules(userMessages: any[], exchanges: number): string[] {
  const improvements = [];
  
  if (exchanges < 4) {
    improvements.push('Try to extend conversations longer to practice more scenarios');
  }
  
  const avgLength = userMessages.reduce((sum, msg) => sum + msg.message.length, 0) / userMessages.length;
  if (avgLength < 20) {
    improvements.push('Consider providing more detailed responses to build rapport');
  }
  
  if (!userMessages.some(msg => msg.message.includes('?'))) {
    improvements.push('Ask more questions to engage with the character');
  }
  
  if (improvements.length === 0) {
    improvements.push('Continue practicing to build confidence and fluency');
  }
  
  return improvements;
}

function generateCoachingInsights(scores: any, scenario: any) {
  return {
    immediate_actions: [
      'Continue practicing similar scenarios to build confidence',
      'Focus on asking more engaging questions'
    ],
    practice_areas: [
      'Extending conversation length',
      'Building rapport with characters'
    ],
    advanced_techniques: [],
    next_scenarios: [
      `Try another ${scenario.role} scenario at ${scenario.difficulty} level`
    ]
  };
}

function generateImprovementAreas(scores: any): string[] {
  return [
    'Conversation depth and engagement',
    'Question asking techniques',
    'Building stronger rapport'
  ];
}

function generateStrengths(scores: any): string[] {
  return [
    'Professional communication style',
    'Active participation',
    'Appropriate conversation flow'
  ];
}

function generateNextFocus(scores: any, scenario: any): string {
  return `Continue practicing ${scenario.role} scenarios and focus on extending conversation length and depth.`;
}

function calculateProgression(overallScore: number) {
  if (overallScore < 2.5) return { level: 'Developing', next: 'Foundation Building', progress: Math.round(overallScore * 20) };
  if (overallScore < 3.5) return { level: 'Improving', next: 'Skill Development', progress: Math.round(overallScore * 20) };
  if (overallScore < 4.2) return { level: 'Proficient', next: 'Advanced Techniques', progress: Math.round(overallScore * 20) };
  return { level: 'Advanced', next: 'Mastery', progress: Math.round(overallScore * 20) };
}

// Create minimal fallback analysis if everything fails
function createFallbackAnalysis(request: any) {
  return {
    session_id: 'unknown',
    overall_score: 3.0,
    role_scores: { // Changed from category_scores to role_scores
      opening_rapport: { score: 3.0, feedback: 'Good conversation participation' },
      discovery_needs: { score: 3.0, feedback: 'Effective communication approach' },
      communication_clarity: { score: 3.0, feedback: 'Clear professional interaction' },
      problem_solving: { score: 3.0, feedback: 'Good problem-solving engagement' },
      professionalism: { score: 3.0, feedback: 'Professional demeanor maintained' }
    },
    conversation_analysis: {
      specific_strengths: ['Participated actively in the conversation'],
      specific_improvements: ['Continue practicing to build confidence'],
      conversation_flow_analysis: 'Maintained good conversation flow',
      character_interaction_quality: 'Professional interaction throughout',
      ai_assessment: 'Basic feedback analysis'
    },
    coaching_insights: {
      immediate_actions: ['Continue practicing regularly'],
      practice_areas: ['General communication skills'],
      advanced_techniques: [],
      next_scenarios: ['Try similar scenarios for more practice']
    },
    improvement_areas: ['Continue skill development'],
    strengths: ['Active participation'],
    next_session_focus: 'Keep practicing to build confidence',
    skill_progression: { level: 'Developing', next: 'Skill Building', progress: 60 },
    personalized_feedback: 'Good practice session! Keep working on your communication skills.',
    timestamp: new Date().toISOString(),
    analysis_type: 'minimal-fallback'
  };
}

// Build prompt for AI analysis
function buildAnalysisPrompt(conversation: any[], scenario: any) {
  const conversationText = conversation.map((msg, i) => 
    `${i + 1}. ${msg.speaker === 'user' ? 'TRAINEE' : scenario.character_name}: "${msg.message}"`
  ).join('\n');

  return `Analyze this ${scenario.role} roleplay conversation and provide specific feedback.

SCENARIO: ${scenario.title}
CHARACTER: ${scenario.character_name} (${scenario.character_role})
DIFFICULTY: ${scenario.difficulty}

CONVERSATION:
${conversationText}

Provide analysis in this format:

OVERALL_SCORE: [1-5 score]

CATEGORY_SCORES:
Opening_Rapport: [score] | [brief feedback]
Discovery_Needs: [score] | [brief feedback]  
Communication_Clarity: [score] | [brief feedback]
Problem_Solving: [score] | [brief feedback]
Professionalism: [score] | [brief feedback]

STRENGTHS:
• [specific strength 1]
• [specific strength 2]

IMPROVEMENTS:
• [specific improvement 1]
• [specific improvement 2]

FEEDBACK: [2-3 sentences of personalized feedback]

NEXT_FOCUS: [recommendation for next practice]`;
}

// Parse AI response into structured format
function parseAIAnalysis(aiResponse: string, conversation: any[], scenario: any) {
  const lines = aiResponse.split('\n').filter(line => line.trim());
  
  let overall_score = 3.0;
  const category_scores: any = {};
  const strengths: string[] = [];
  const improvements: string[] = [];
  let feedback = '';
  let next_focus = '';
  
  for (const line of lines) {
    if (line.includes('OVERALL_SCORE:')) {
      const match = line.match(/(\d+\.?\d*)/);
      if (match) overall_score = Math.min(5.0, Math.max(1.0, parseFloat(match[1])));
    } else if (line.includes(':') && line.includes('|')) {
      const [key, value] = line.split('|');
      const scoreMatch = key.match(/(\d+\.?\d*)/);
      if (scoreMatch) {
        const categoryName = key.split(':')[0].trim().toLowerCase().replace(/\s+/g, '_');
        category_scores[categoryName] = {
          score: Math.min(5.0, Math.max(1.0, parseFloat(scoreMatch[1]))),
          feedback: value.trim()
        };
      }
    } else if (line.startsWith('• ')) {
      const content = line.substring(2).trim();
      if (line.includes('STRENGTHS:') || strengths.length > 0 && improvements.length === 0) {
        strengths.push(content);
      } else if (line.includes('IMPROVEMENTS:') || improvements.length > 0) {
        improvements.push(content);
      }
    } else if (line.includes('FEEDBACK:')) {
      feedback = line.replace('FEEDBACK:', '').trim();
    } else if (line.includes('NEXT_FOCUS:')) {
      next_focus = line.replace('NEXT_FOCUS:', '').trim();
    }
  }

  // Ensure we have required categories
  const requiredCategories = ['opening_rapport', 'discovery_needs', 'communication_clarity', 'problem_solving', 'professionalism'];
  requiredCategories.forEach(cat => {
    if (!category_scores[cat]) {
      category_scores[cat] = {
        score: overall_score,
        feedback: 'Good performance in this area'
      };
    }
  });

  return {
    overall_score,
    role_scores: category_scores, // Changed from category_scores to role_scores
    conversation_analysis: {
      specific_strengths: strengths.length > 0 ? strengths : ['Active participation in conversation'],
      specific_improvements: improvements.length > 0 ? improvements : ['Continue building confidence'],
      conversation_flow_analysis: 'Good conversation flow maintained throughout',
      character_interaction_quality: `Professional interaction with ${scenario.character_name}`,
      ai_assessment: 'AI-powered analysis of conversation content'
    },
    coaching_insights: {
      immediate_actions: ['Continue regular practice'],
      practice_areas: ['Building conversation depth'],
      advanced_techniques: [],
      next_scenarios: [`Try more ${scenario.role} scenarios`]
    },
    improvement_areas: improvements.slice(0, 3),
    strengths: strengths.slice(0, 3),
    next_session_focus: next_focus || 'Continue practicing to build confidence',
    skill_progression: calculateProgression(overall_score),
    personalized_feedback: feedback || 'Good practice session with room for continued growth'
  };
}
